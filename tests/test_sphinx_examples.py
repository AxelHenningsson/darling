"""Parse python files and look for inline sphinx comments that represents examples.

I.e comments that starts with ".. code-block:: python" are parsed and the python code is returned
as a strings.

We then write example code to a temp file module and import to check for any obvious errors.

This is essentially  a simplified version of the doctest native module in python. It makes me feel
more comfortable to have it re-implemented by my own hand as doctesting inherently will make
exec() calls allowing for arbitrary code execution, should someone put malicious code in the
docstrings....
"""

import os
import re
import shutil
import textwrap
import unittest


class TestDocsExamples(unittest.TestCase):
    def setUp(self):
        self.root_path = os.path.abspath(
            os.path.join(os.path.abspath(__file__), "..", "..")
        )
        self.package_path = os.path.join(self.root_path, "darling")
        self.test_path = os.path.join(self.root_path, "tests")
        self.debug = False

        self.snapshot = []
        for file in os.listdir(self.test_path):
            self.snapshot.append(file)

        self.python_files, self.code_snippets = self.extract_sphinx_code(
            self.package_path
        )

        print(
            f"Collected {len(self.code_snippets)} docstring examples from {len(self.python_files)} .py files"
        )

    def _exec(self, code):
        old_cwd = os.getcwd()
        try:
            os.chdir(self.test_path)
            exec(code, {})
        finally:
            os.chdir(old_cwd)

    def tearDown(self):
        """move any non-python files generated by docstring examples into
        the saves directory to keep the test directory clean
        """
        for file in os.listdir(self.test_path):
            if file not in self.snapshot and not file.endswith(".py"):
                print(
                    f"moving {os.path.join(self.test_path, file)} to {os.path.join(self.test_path, 'saves', file)}"
                )
                shutil.move(
                    os.path.join(self.test_path, file),
                    os.path.join(self.test_path, "saves", file),
                )

    def test_docs_examples(self):
        """execute strings of python code and check for obvious errors."""
        errmsg = ""
        for pyfile, snippet in zip(self.python_files, self.code_snippets):
            if self.debug is False:
                snippet = snippet.replace("plt.show()", "# plt.show()")
            print(f"executing example from {pyfile}...")
            try:
                self._exec(snippet)
            except Exception as e:
                msg = f"Sphinx docs example in {pyfile} failed to execute: \n>>\n{snippet}>> \n"
                errmsg += msg + "\n" + str(e) + "\n"
        if len(errmsg) > 0:
            raise ValueError(errmsg)

    def extract_sphinx_code(self, directory):
        """Recursively parse all python files in a directory for docstrings.

        I.e comments that starts with ".. code-block:: python" are parsed and
        the python code is returned as a strings. Note that the doc examples
        must end with 2 blank lines to be parsed correctly. This is the trigger
        for - end of example code -.

        Args:
            directory (:obj: `str`): path to directory to traverse and parse.

        Returns:
            (:obj:`list` of `str`):: The python code snippets.
        """
        # Pattern to capture entire Sphinx docstrings (triple-quoted strings)
        sphinx_docstring_pattern = re.compile(r"\"\"\"(.*?)\"\"\"", re.DOTALL)
        code_snippets = []
        python_files = []

        for root, _, files in os.walk(directory):
            for file in files:
                if file.endswith(".py"):
                    file_path = os.path.join(root, file)

                    with open(file_path, "r", encoding="utf-8") as f:
                        content = f.read()

                        # Find all Sphinx-style docstrings
                        for docstring in sphinx_docstring_pattern.findall(content):
                            reading = False
                            doc_lines = docstring.split("\n")
                            for i, line in enumerate(doc_lines):
                                # extract example code
                                if ".. code-block:: python" in line:
                                    reading = True
                                    example = ""
                                    blank_line_counter = 0
                                elif reading:
                                    example += line + "\n"
                                    if line.strip() == "":
                                        blank_line_counter += 1
                                    else:
                                        blank_line_counter = 0
                                    if blank_line_counter == 2:
                                        reading = False
                                        example = textwrap.dedent(example)
                                        code_snippets.append(example)
                                        python_files.append(file)

        return python_files, code_snippets


if __name__ == "__main__":
    unittest.main()
